# Отчет по второму этапу

## В качестве очереди были рассмотрены

- ArrayBlockingQueue<> - с указанием длины очереди
- LinkedBlockingQueue<> - c указанием длины очереди
  Другие очереди не подходят нам, бытрее оказалась ArrayBlockingQueue использует внутренний массив для хранения элементов, что обеспечивает более эффективный доступ к элементам в памяти.

## Выбор количество тредов обработки запросов к dao
После добавление многопоточной обработки запросов в дао,
используя wrk с параметрами -c 128 -t 128 для создания большого количества get запросов,
поэкспериментирем с количеством потоков для обработки 2, 4, 8, 16, 32 - колчиство ядер у меня 8 с 2 потоками на ядро.

- 2 - 25000 при средней задержке 1.27ms
- 4 - 33000 при средней задержке 46ms
- 8 - 40000 при средней задержке 79ms
- 16 - 37000 при средней задержке 73ms
- 32 - 32000 при средней задержке 94ms

Делаем вывод оптимальное значение 8 потоков.

## Сделаем замер для точек расладки при put и get

Все замеры проводились на проретом и наполненом сервере

### get

Значение в 39000 было получено, при более высоких значениях максимальные задержи были очень большими
В файлах в папке results приведены дополнителные все замеры.